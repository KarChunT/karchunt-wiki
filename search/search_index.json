{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to KarChunT Wiki","text":"<p>Hi, I'm Kar Chun! I'm an Infrastructure and DevOps Engineer at Intel. Welcome to my website, visit my website for documentation, tutorials, blog and more. I love to code and design software architecture.</p> <p>My ambition is to develop a new technology that can revolutionize the world. As part of my motivation to inspire people, this site shares what I have learned and studied previously. It would be the greatest thing I could ever hope for if someone looked at me and said, <code>Thanks to you, I didn't give up</code>\ud83e\udd73.</p> <p>You can contact me via these channels!</p> <ul> <li>Website</li> <li>GitHub</li> <li>LinkedIn</li> <li>Newsletter</li> <li>Email</li> </ul> <p>Here is my Credly profile, where you can find my certifications and badges. It is my hope that you can find something useful or helpful here. Thank you!</p>"},{"location":"docs/","title":"Documentation","text":"<ul> <li> <p> Secure Shell Protocol (SSH)</p> <p>SSH stands for Secure Shell (SSH) Protocol that is mainly used to connect to a Linux server remotely.</p> <p> Getting Started</p> </li> <li> <p> 12 Factor App</p> <p>It is a methodology for building software-as-a-service applications with best practices</p> <p> Getting Started</p> </li> </ul>"},{"location":"docs/12-factor-app/","title":"12 Factor App","text":"<p>Info</p> <p>Documentation - 12factor.net</p>"},{"location":"docs/12-factor-app/#what-is-12-factor-app","title":"What is 12 Factor App?","text":"<p>It's a methodology for building software-as-a-service (SaaS) or Cloud Native applications by providing a set of best practices to create web apps that are easy to deploy, scalable, maintainable, portable, and resilient.</p> <ul> <li>App can run in different execution environments without having the change the source code (Portability).</li> <li>Suitable for deployment on modern cloud platforms</li> <li>Minimize divergence between development and production</li> <li>Enable continuous deployment</li> <li>Easy to scale up</li> </ul>"},{"location":"docs/12-factor-app/#the-twelve-factors","title":"The Twelve Factors","text":"<p>Developers should consider 12 factors when building SaaS applications in accordance with this methodology. Of course, this methodology is not limited to building SaaS applications, instead, it can apply to other applications as well.</p>"},{"location":"docs/12-factor-app/#codebase","title":"Codebase","text":"<p>In summary, a codebase is always tracked in a version control system such as Git, and every app has only one codebase, but it will be deployed many times.</p> <ul> <li>Codebase = repository</li> <li>One to one relationship between codebase and app</li> <li>I'm referring app = service</li> </ul> <p>Imagine that you have a food web application that collaborates with multiple developers. So far, it only offers food ordering service. However, you need to ensure that the codebase of all developers is the same so that all deployments are consistent. In this case, Git will help all developers work on the same application at the same time, since everyone will push or pull changes from a central location like GitHub, GitLab, etc.</p> Folder structure<pre><code>Food web application/\n\u251c\u2500\u2500 ordering-service/\n\u2502   \u2514\u2500\u2500 source_code.py\n\u251c\u2500\u2500 delivery-service/\n\u2502   \u2514\u2500\u2500 source_code.py\n\u2514\u2500\u2500 payment-service/\n    \u2514\u2500\u2500 source_code.py\n</code></pre> <p>In the future, we may have delivery service, payment service, etc, but now the codebase has all the related services. When you have multiple application services, it's a distributed system and multiple application services sharing the same codebase already violates the 12 Factor.</p> <p></p> <p>So, we can separate those services into its own codebase, and within that codebase, we can have multiple deploys. Therefore, each service in a distributed system can comply with (obey) 12 factor.</p>"},{"location":"docs/12-factor-app/#dependencies","title":"Dependencies","text":"<p>In summary, all dependencies should be explicitly declare and isolate dependencies. It does not rely on implicit existence of system tools or libraries or packages.</p> app.py<pre><code>from fastapi import FastAPI\n\napp = FastAPI(\n  title='Notifications',\n  description='This is notification API',\n  version='0.1.0'\n)\n\nnotifications = [\n  {'name': 'Raymond Melton', 'message': 'Fight and road more hard whose.'},\n  {'name': 'Kevin Dunn', 'message': 'Ten environmental soldier often.'},\n]\n\n@app.get(\"/notifications\")\ndef get_all_notifications():\n  return notifications\n</code></pre> <p>Let's take a look on this example. We're building a backend services using FastAPI Python web framework. Before you start coding, you have to install this FastAPI Python web framework first.</p> <p>If we based on the 12 factor Dependencies concept.</p> <p>It does not rely on implicit existence of system tools or libraries or packages.</p> <p>That means, there is no guarantee that dependencies such as FastAPI will exist on the system where your application will be run. So, you have to declare all dependencies and isolate the dependencies as well. In Python;</p> <ul> <li>pip is used for declaration: <code>pip install -r requirements.txt</code></li> </ul> requirements.txt<pre><code>fastapi==0.45.0\n</code></pre> <ul> <li>virtualenv is used for isolation: <code>python -m venv venv</code>. As a result, we will be able to create an isolated environment for each application with its own version of dependencies.</li> </ul> <p>However, how about those <code>curl</code>, <code>wget</code>, and other tools that are dependent on the system. What we can do, is using Docker, as Docker container is a standalone or executable package of software that has everything like application source code, tools, libraries, dependencies, etc that you need to run an application.</p>"},{"location":"docs/12-factor-app/#config","title":"Config","text":"<p>In summary, we will need to store config in the environment variables, as configuration may be different between deployments.</p> app.py<pre><code>from fastapi import FastAPI\nimport mysql.connector\n\napp = FastAPI(\n  title='Notifications',\n  description='This is notification API',\n  version='0.1.0'\n)\n\n# Creating connection object\nmydb = mysql.connector.connect(\n  host = \"localhost\",\n  user = \"username\",\n  password = \"password\",\n  database = \"test\"\n)\n\ncursorObject = mydb.cursor()\n\n@app.get(\"/notifications\")\ndef get_all_notifications():\n  query = \"SELECT * FROM NOTIFICATIONS\"\n  cursorObject.execute(query)\n  myresult = cursorObject.fetchall()\n  return myresult\n</code></pre> <p>Let's take a look on this example. Right now, we're hard-coded the mysql host, user, password, and database values in the code. This already violates the 12 factor methodology concept, as the database configuration may be different between deployments.</p> .env<pre><code>HOST=localhost\nUSER=username\nPASSWORD=password\nDATABASE=test\n</code></pre> <p>So, we have to keep those configuration separately. What we can do is creating an <code>.env</code> file with those config values and inject this <code>.env</code> file into environment variable in the code.</p> app.py<pre><code>import os\nimport mysql.connector\n\nfrom fastapi import FastAPI\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\napp = FastAPI(\n  title='Notifications',\n  description='This is notification API',\n  version='0.1.0'\n)\n\n# Creating connection object\nmydb = mysql.connector.connect(\n  host = os.getenv('HOST'),\n  user = os.getenv('USER'),\n  password = os.getenv('PASSWORD'),\n  database = os.getenv('DATABASE')\n)\n\ncursorObject = mydb.cursor()\n\n@app.get(\"/notifications\")\ndef get_all_notifications():\n  query = \"SELECT * FROM NOTIFICATIONS\"\n  cursorObject.execute(query)\n  myresult = cursorObject.fetchall()\n  return myresult\n</code></pre> <p>With this setup, we can use different configurations for different deployments, without compromising any credentials.</p>"},{"location":"docs/12-factor-app/#backing-services","title":"Backing Services","text":"<p>What is backing services?</p> <p>Any service the app consumes over the network.</p> <p>In summary, we will treat all backing services as attached resources.</p> <p>Example of Backing services;</p> <ul> <li>database (MySQL, PostgreSQL)</li> <li>caching (Redis)</li> <li>Messaging/queueing systems (Kafka, RabbitMQ)</li> <li>SMTP</li> <li>etc</li> </ul> <p>It makes no distinction between local and third party services</p> <p>\u2014 12factor.net</p> <p></p> <p>Imagine you have integrated PostgreSQL service to your application to store your data. A PostgreSQL database is an attached resource to your app, which can be run locally, in the cloud, or on a server. If it is hosted somewhere, it will work without having to change the application code since all the configurations, such as URL, credentials, etc., are stored in a config file like <code>.env</code>.</p>"},{"location":"docs/12-factor-app/#build-release-run","title":"Build, release, run","text":"<p>In summary, we will need to strictly separate the stage of building, release, and running.</p> <p></p> <ul> <li> <p>build stage</p> <ul> <li>Transform or convert the code into an executable or binary format. For example, you have a Python application that's going to run on Windows or Linux server, you can use setup tools to build the application, while in Java, you can use maven or etc to build the application. Of course you can use Docker as well.</li> <li>The build stage compiles assets and binaries based on vendor dependencies and the code.</li> </ul> </li> <li> <p>release stage</p> <ul> <li>It combines the executable file and config file to become the release object.</li> <li>executable + config = release object</li> <li>Every release should have a unique release Id. For example, timestamp (2024-05-11-13-30-10) or incrementing number (v1, v2, v3)</li> <li>Any changes to the codebase must create a new release and once a release has been created, it cannot be modified.</li> </ul> </li> <li> <p>run stage (also known as \"runtime\")</p> <ul> <li>Run the release object in the respective environment. You can deploy and run the release object into different environments and this will ensure that all environments will have the same codebase as they're coming from the same release object.</li> </ul> </li> </ul> <p>With that said, we can easily roll back to the previous releases based on the build artifacts that generated from the build stage.</p>"},{"location":"docs/12-factor-app/#processes","title":"Processes","text":"<p>In summary, applications should be deployed as one or more stateless processes (persist data stored on a backing service) and share-nothing.</p> app.py<pre><code>from flask import Flask\n\napp = Flask(__name__)\ntotal_visit = 0\n\n@app.route(\"/\")\ndef homepage():\n  global total_visit\n  total_visit += 1\n  return \"Welcome to my homepage\"\n\nif __name__ == \"__main__\":\n  app.run(host=\"0.0.0.0\")\n</code></pre> <p></p> <p>Let's take a look on this example. Right now, we have a <code>total_visit</code> global variable, it will increase it each time when the request/user comes in, but this only works with one application. Having multiple applications means they will each have their own version of this variable and they will not sync with each other (record everything separately), as the memory state is different (single-transaction cache).</p> <p>The another scenario is that when the user login to the website, normally we will cache the user session data. But, if we store all these user sessions data in the process memory or filesystem of the app, then when the user is redirected to another application, what will happen is that the user session data isn't available. Of course, it is possible to use sticky sessions to redirect the same user to the same application using load balancers. However, there is the possibility that the application may crash. In that case, all the data or sessions will be lost.</p> <p></p> <p>Sticky sessions are a violation of 12 factor and should never be used or relied upon. So, we should store all the data and session information on a backing service like database or caching system. Redis is a good option for storing session state data as it offers time-expiration.</p>"},{"location":"docs/12-factor-app/#port-binding","title":"Port binding","text":"<p>In summary, we have to export services via port binding, as 12 factor app is completely self-contained (services) and does not rely on a specific web server to function. This means that by declaring the port your application uses, the runtime and development environment know where to access your services. You must do this to ensure portability across platforms and environments.</p> app.py<pre><code>import os\nfrom flask import Flask\n\napp = Flask(__name__)\n\n@app.route(\"/\")\ndef hello_world():\n    return \"&lt;p&gt;Hello, World!&lt;/p&gt;\"\n\nif __name__ == '__main__':\n    app.run(debug=True, port=os.environ.get(\"PORT\", 5000))\n</code></pre> <p>For example, Flask application is using port 5000 by default. So, in the web application, HTTP is exported as a service by binding to a port 5000 and listening for requests. That means in local development environment, you can visit a service url like <code>http://localhost:5000</code> to access the service exported by their app.</p>"},{"location":"docs/12-factor-app/#concurrency","title":"Concurrency","text":"<p>In summary, we have to scale out via the process model. So the applications should scale out horizontally and not vertically by running multiple instances of the application concurrently.</p> <p></p> <p>As an example, you currently have one instance of your application serving multiple users. What if you have more users visiting your application? It's possible to scale your resources vertically by adding resources (RAM, Storage, etc) to the server, but that means the server must be taken down. This approach isn't good.</p> <p></p> <p>Because processes are the first class citizens of the twelve-factor app, we should scale out horizontally by adding/provisioning more servers so we can spin more instances. Of course, you can have a load balancer as well to balance your load across the instances of the application.</p>"},{"location":"docs/12-factor-app/#disposability","title":"Disposability","text":"<p>In summary, we will need to maximize robustness of a system with fast startup and graceful shutdown, as 12 factor app's processes are disposable, meaning they can be started or stopped at a moment's notice.</p> <p></p> <p>It's important for processes to make an effort to minimize startup time by avoiding complex startup scripts for provisioning the application and this concept also applies to reduce instances of the application.</p> <p>Processes shut down gracefully when they receive a SIGTERM signal from the process manager.</p> <p>\u2014 12factor.net</p> <p></p> <p>Here is an example, when executing the <code>docker stop</code> command for Docker containers, Docker initiates the SIGTERM signal to the container initially. If the container does not stop within a grace period, Docker will then send the SIGKILL signal to forcibly terminate the process running within the container.</p> <p>Info</p> <p>SIGTERM -&gt; SIGKILL -&gt; Terminate container process</p> <p>These two signals will allow the application to gracefully shutdown by stopping the acceptance of new requests and ensuring the completion of all ongoing requests. Therefore, this will prevent any impact on users who are waiting for a response from the application.</p>"},{"location":"docs/12-factor-app/#devprod-parity","title":"Dev/prod parity","text":"<p>In summary, we have to keep development, staging, and production environments as similar as possible by applying CI/CD concept.</p> <p></p> <p>Typically, there is a disconnect between the development and production environments, leading to gaps that can be categorized into three distinct areas</p> <ul> <li> <p>Time gap</p> <ul> <li>It could take the developer days, weeks, or even months to finalize code modifications and move them to production.</li> </ul> </li> <li> <p>Personnel gap</p> <ul> <li>Developers are responsible for writing code, while Ops engineers handle the deployment of changes. However, in most cases, they have limited or no knowledge about the new changes, making it difficult to identify issues caused by these new changes.</li> </ul> </li> <li> <p>Tools gap</p> <ul> <li>Different tools used in different environments, often leading to unforeseen outcomes (consequences). For instance, developers may use SQLite and Nginx in development environment, whereas MySQL and HAProxy use in production environment.</li> </ul> </li> </ul> <p>The twelve-factor app is designed for continuous deployment by keeping the gap between development and production small. The twelve-factor developer resists the urge to use different backing services between development and production.</p> <p>\u2014 12factor.net</p> <p>By applying Continuous Integration, Continuous Delivery, and Continuous Deployment. We can</p> <ul> <li>make the time gap small, as the developer can write code and deploy it in a matter of hours or even minutes.</li> <li>make the personnel gap small, the developer who writes the code is actively involved in deploying it and monitoring its behavior in production.</li> <li>make the tools gap small, we must ensure the tools as similar as possible that are being used in development and production environment. (Example: Docker)</li> </ul> Areas Traditional app 12-factor app Time Weeks or Months Hours or minutes Personnel Different people, Developer and Ops Engineers Same people, Developer Tools Different As similar as possible"},{"location":"docs/12-factor-app/#logs","title":"Logs","text":"<p>In summary, we need to treat logs as event streams and leave the execution environment to aggregate.</p> <p></p> <p>Logs give insight into how a running app behaves, such as detecting errors in code and recording all incoming requests. Normally, we save logs in a local file called <code>logfile</code>. However, this method has a drawback. In the era of containers, the container could be terminated at any moment, causing the logs to disappear.</p> <p></p> <p>In a different situation, an application may choose to send logs to a centralized logging system like fluentd. Although this is encouraged, it is not advisable to tightly couple or rely exclusively on that particular logging solution for the application.</p> <p>A twelve-factor app never concerns itself with routing or storage of its output stream.</p> <p>\u2014 12factor.net</p> <p></p> <p>We should</p> <ul> <li>Ensure your logs are stored in a structured format (JSON) and kept in a centralized location for easy access. An agent can easily transfer log data to a central location for querying, consolidating, and analyzing.</li> <li>Avoid writing to a particular file or being restricted to a specific logging system.</li> </ul>"},{"location":"docs/12-factor-app/#admin-processes","title":"Admin processes","text":"<p>In summary, admin/management tasks should be run as one-time processes, stored in source control, and separate them from application processes and they should be running on the same systems as the production application.</p> <p></p> <p>Let's say you discover that the total number of visits recorded in your webpage's PostgreSQL database is inaccurate. In such cases, you can reset the count. To do this, you can create a script that performs the reset as a one-time task. This process is similar to other tasks like database migration or fixing specific issues.</p> <p>You need to ensure the admin task is running on the same systems as the production application, but as a separate process.</p>"},{"location":"docs/ssh/host-configuration/","title":"Host Configuration","text":""},{"location":"docs/ssh/host-configuration/#host-specific-configuration-file","title":"Host Specific Configuration file","text":"<p>Create a config filename <code>config</code> in your local <code>~/.ssh</code> directory.</p> <pre><code>nano ~/.ssh/config\n</code></pre> <p>You can define each individual SSH configuration options into this file. You can find all the SSH configuration options from this ssh_config.</p> ~/.ssh/config<pre><code>Host * # all hosts\n  ServerAliveInterval 180\n  StrictHostKeyChecking no\n  UserKnownHostsFile /dev/null\n\nHost &lt;remove-alias&gt;\n  HostName &lt;remote-host/ipaddress&gt;\n  Port &lt;port-number&gt;\n  User &lt;username&gt;\n\nHost &lt;remote-alias&gt;\n  HostName &lt;remote-host/ipaddress&gt;\n  Port &lt;port-number&gt;\n\n# sample\nHost server1\n  HostName 192.168.0.1\n  Port 22\n  User karchunt\n</code></pre> Declaration Description Host * All hosts Host <code>remote-alias</code> You can name <code>remote-alias</code> whatever you want ServerAliveInterval If set 180, then every 3 minutes, send a packet to the server to let it know not to close the connection StrictHostKeyChecking If set \"no\", it will disable host checking and it will auto-add new hosts to the <code>known_hosts</code> file (fingerprint) directly UserKnownHostsFile Not warn on new or changed hosts HostName remove host name or IP Address Port Port number to access User Username used to access"},{"location":"docs/ssh/local-tunneling/","title":"Local Tunneling","text":"More Information <p>A Visual Guide to SSH Tunnels: Local and Remote Port Forwarding</p>"},{"location":"docs/ssh/local-tunneling/#local-tunneling-to-a-server","title":"Local tunneling to a server","text":"<p>Traffic between the localhost and remote host can be tunneled via SSH connections. To establish a local tunnel on your remote server, use <code>-L</code> parameter when connecting and must provide</p> <ul> <li>Local port for accessing the tunneled connection</li> <li>Remote host IP/name</li> <li>Remote host port</li> </ul> <p>For general usage, connect to <code>10.0.0.12</code> on port 80 on your remote host, then your local machine is able to ping or make the connection to the remote host through port 8080.</p> <pre><code>ssh -f -N -L &lt;local-port&gt;:&lt;remote-host-ip-address/name&gt;:&lt;remote-port&gt; &lt;username&gt;@&lt;host&gt;\n# example\nssh -L 8080:10.0.0.12:80 username@host\n</code></pre> <p>Now if you go to your browser/curl to <code>localhost:8080</code>, you are able to see the content that hosted at <code>10.0.0.12:80</code>.</p> Parameters Description -f let SSH go into the background before executing -N does not open a shell or execute a program on the remote side -L establish a local tunnel to your remote server <p>If you want to terminate the background connection, you have to find the PID and kill it.</p> <pre><code>ps aux | grep &lt;local-port&gt;\nkill &lt;process-id&gt;\n</code></pre> <pre><code>Output\n1001      5965  0.0  0.0  48168  1136 ?        Ss   12:28   0:00 ssh -f -N -L 8888:your_domain:80 username@remote_host\n1001      6113  0.0  0.0  13648   952 pts/2    S+   12:37   0:00 grep --colour=auto 8888\n</code></pre> <pre><code>kill 5965\n</code></pre>"},{"location":"docs/ssh/local-tunneling/#local-tunneling-local-network","title":"Local tunneling local network","text":"<p>You can tunnel remote host local network to your local. Here is the animation diagram of the local network web server and common SSH server.</p> <p></p> <pre><code>ssh -L 8080:localhost:8080 user@server\n</code></pre>"},{"location":"docs/ssh/local-tunneling/#local-tunneling-private-network","title":"Local tunneling private network","text":"<p>You can tunnnel remote host private network to your local. Here is the animation diagram of the private network web server and common SSH server.</p> <p></p> <pre><code>ssh -L &lt;local-port&gt;:&lt;server-ip-address&gt;:&lt;server-port&gt; &lt;username&gt;@&lt;bastion-server-ip-address&gt;\nssh -L 8080:10.0.0.12:8080 user@bastion\n</code></pre>"},{"location":"docs/ssh/play-with-ssh-keys/","title":"Play with SSH Keys","text":""},{"location":"docs/ssh/play-with-ssh-keys/#generating-an-ssh-key-pair","title":"Generating an SSH Key Pair","text":"<p>Your first step should be creating a new SSH key pair on your computer, then you can connect without a password to a remote server.</p> <pre><code># You can leave those settings as default by pressing ENTER\nssh-keygen\nssh-keygen -t dsa -C \"Comment\" -b 4096\n\n# make sure your private key file exists\nssh-keygen -p # remove or change passphrase on private key\nssh-keygen -l # display the SSH key fingerprint\n</code></pre> <p>For your information, private key's passphrase is just to secure the private key, so that no one will gain access to the remote server even they have your private key, but you have to enter your private key's passphrase everytime if you want to initiate a SSH connection, but this can avoid by using SSH agent.</p> <p>It will generate <code>id_rsa</code> and <code>id_rsa.pub</code> key file to <code>/home/&lt;username&gt;/.ssh</code> hidden directory.</p> <ul> <li><code>id_rsa</code> = private key</li> <li><code>id_rsa.pub</code> = public key</li> </ul>"},{"location":"docs/ssh/play-with-ssh-keys/#optional-parameters","title":"Optional Parameters","text":"Parameters Description Example -t Type of cryptographic algorithms. Default is RSA. rsa, dsa, ecdsa, ed25519 -C Comment simple comment -b The number of bits, default is 2048 bits 4096 -p Removing or changing passphrase on private key (make sure private key file exists) Your password or leave it empty -l Displaying the SSH key fingerprint (make sure private key file exists) -"},{"location":"docs/ssh/play-with-ssh-keys/#copy-the-public-ssh-key-to-the-server","title":"Copy the public SSH key to the server","text":"<p>You can authenticate yourself to the server without a password (passwordless), but you have to copy your public key to the server. There are multiple ways to do it.</p>"},{"location":"docs/ssh/play-with-ssh-keys/#using-ssh-copy-id-command","title":"Using <code>ssh-copy-id</code> command","text":"<pre><code>ssh-copy-id &lt;username&gt;@&lt;remote-server-ip-address/name&gt;\n\n# You can specify the public key through through \"-i\" option\nssh-copy-id -i &lt;public-key-path&gt; &lt;username&gt;@&lt;remote-server-ip-address/name&gt;\n</code></pre> <p>After you type the remote server password, it will copy your public key from your local file <code>~/.ssh/id_rsa.pub</code> to remote server <code>~/.ssh/authorized_keys</code> file.</p>"},{"location":"docs/ssh/play-with-ssh-keys/#manually-copy-ssh-public-key-from-local-to-a-server","title":"Manually copy SSH public key from local to a server","text":"<pre><code># You can copy your local public key through any methods you like\ncat ~/.ssh/id_rsa.pub\nmkdir -p ~/.ssh\necho \"&lt;public_key&gt;\" &gt;&gt; ~/.ssh/authorized_keys\n\n# combination\ncat ~/.ssh/id_rsa.pub | ssh &lt;username&gt;@&lt;remote-server-ip-address/name&gt; \"mkdir -p ~/.ssh &amp;&amp; cat &gt;&gt; ~/.ssh/authorized_keys\"\n</code></pre>"},{"location":"docs/ssh/play-with-ssh-keys/#using-an-ssh-agent-to-avoid-typing-your-private-key-passphrase","title":"Using an SSH agent to avoid typing your private key passphrase","text":"<p>Assume you had set your private SSH key with a passphrase, but you want to eliminate the typing of the private key passphrase. SSH Agent comes into the play to solve this kind of problem.</p> <p>Once the passphrase is entered for the first time, the SSH agent will store your private key to the agent so you don't have to reenter it again.</p> <pre><code># start SSH agent\neval $(ssh-agent)\n\nssh-add # add your private key to agent, default to id_rsa\nssh-add &lt;private-key-path&gt; # You can specify the private key path\n</code></pre>"},{"location":"docs/ssh/play-with-ssh-keys/#forward-ssh-credentials-to-use-on-a-server","title":"Forward SSH credentials to use on a server","text":"<p>In order to connect to one server without a password from within another, you must forward the SSH key information.</p> <p>Before you proceed, you need to make sure your SSH agent starts and your SSH key is added to the agent (ssh-add).</p> <pre><code># forwards your credentials to the server for this session\nssh -A &lt;username&gt;@&lt;remote-server-ip-address/name&gt;\n</code></pre> <p>This will allow you to SSH into any other host that your SSH key has permission to access because the server that you are connected to right now will \"know\" your private SSH key on this server.</p>"},{"location":"docs/ssh/remote-server-configuration/","title":"Remote Server Connection","text":""},{"location":"docs/ssh/remote-server-configuration/#connecting-to-a-remote-server","title":"Connecting to a remote server","text":"<pre><code>ssh &lt;remote-host-ip-address/name&gt; # Your local machine username is same as on the remote server\nssh &lt;username&gt;@&lt;remote-host-ip-address/name&gt; # specify your username if it is different\nssh -p &lt;port-number&gt; &lt;username&gt;@&lt;remote-host-ip-address/name&gt; # specify different port number\nssh -v &lt;username&gt;@&lt;remote-host-ip-address/name&gt; # get the verbose information\n\n# running a single command on a remote host instead of spawning a shell session\n# After the command is completed running, the connection will straightaway close\nssh &lt;username&gt;@&lt;remote-host-ip-address/name&gt; &lt;command-to-run&gt;\nssh &lt;username&gt;@&lt;remote-host-ip-address/name&gt; ls -la\n</code></pre> Parameters Description Example -p Port Number 2222 -v More information (Verbose) - <p>When you SSH to a server, it will prompt you whether you want to connect by showing the fingerprint. It will save the fingerprint to known_hosts file.</p> Info <p>To simplify the connection process, you can create a Host specific configuration file.</p>"},{"location":"docs/ssh/remote-server-configuration/#known_hosts","title":"known_hosts","text":"Info <p>It will generate a <code>known_hosts</code> file in your local <code>~/.ssh</code> directory.</p> <p>A fingerprint will be displayed when you SSH to a server. If you put \"yes\", the system will save the fingerprint to your local <code>~/.ssh/known_hosts</code> file, so you won't have to enter the same thing again next time.</p> <p>As a result, it can help to prevent the man-in-the-middle-attack.</p>"},{"location":"docs/ssh/remote-tunneling/","title":"Remote Tunneling","text":""},{"location":"docs/ssh/remote-tunneling/#remote-tunneling-to-a-server","title":"Remote tunneling to a server","text":"Info <p>The concept is same as local tunneling.</p> <p>A remote tunnel makes a connection to a remote server. The remote port must be specified when creating the remote tunnel. As a result, the remote computer able to connect or access your localhost. To establish a remote tunnel to your remote server, use <code>-R</code> parameter when connecting and must provide</p> <ul> <li>Remote port for accessing the tunneled connection</li> <li>Local host IP/name</li> <li>Local host port</li> </ul> <p>For general usage, connect to <code>localhost</code> on port 8080 on our local computer, then your remote machine is able to ping or make the connetion to the localhost through port 8080.</p> <pre><code>ssh -f -N -R &lt;remote-port&gt;:&lt;local-host-ip-address/name&gt;:&lt;local-port&gt; &lt;username&gt;@&lt;remote-host-ip-address/name/gateway&gt;\n# example\nssh -R 8080:localhost:8080 user@remote-host-ip-address/gateway\n</code></pre> <p>Now if you go to your remote browser/curl to <code>localhost:8080</code>, you are able to see the content that hosted at <code>localhost:80</code>.</p> Parameters Description -R establish a remote tunnel to your remote server"},{"location":"docs/ssh/remote-tunneling/#remote-tunneling-local-network","title":"Remote tunneling local network","text":"<p>You can tunnel your local network to remote host. Here is the animation diagram of the local network web server and common SSH server.</p> <p>Here is the animation diagram of the local network web server and common SSH server.</p> <pre><code>ssh -R 8080:localhost:8080 user@remote-host-ip-address/gateway\nssh -R 0.0.0.0:8080:localhost:8080 user@remote-host-ip-address/gateway\n</code></pre>"},{"location":"docs/ssh/remote-tunneling/#remote-tunneling-private-network","title":"Remote tunneling private network","text":"<p>You can tunnel your local private network to remote host. Here is the animation diagram of the private network web server and common SSH server.</p> <pre><code>ssh -R 8080:&lt;local-server-ip-address&gt;:8080 user@remote-host-ip-address/gateway\nssh -R 0.0.0.0:8080:&lt;local-server-ip-address&gt;:8080 user@remote-host-ip-address/gateway\n</code></pre>"},{"location":"docs/ssh/server-configuration/","title":"Server Configuration","text":""},{"location":"docs/ssh/server-configuration/#disable-password-authentication","title":"Disable password authentication","text":"<p>If you have set up your SSH keys, then my advice is to disable password authentication, as passwordless is more secure than password authentication.</p> <ol> <li> <p>Go to your remote server, find, and edit <code>/etc/ssh/sshd_config</code>.</p> <pre><code>sudo nano /etc/ssh/sshd_config\n</code></pre> </li> <li> <p>Search for <code>PasswordAuthentication</code> text and set it to \"no\".</p> sshd_config<pre><code>PasswordAuthentication no\n</code></pre> </li> <li> <p>Restart the SSH service</p> <pre><code>sudo service ssh restart\n</code></pre> </li> </ol>"},{"location":"docs/ssh/server-configuration/#change-ssh-daemon-runslistens-on-port","title":"Change SSH Daemon runs/listens on port","text":"<p>By default, SSH Daemon runs/listens on port 22. You can change it as well.</p> <ol> <li> <p>Go to your remote server, find, and open <code>/etc/ssh/sshd_config</code>.</p> <pre><code>sudo nano /etc/ssh/sshd_config\n</code></pre> </li> <li> <p>Search for <code>Port</code> text and edit it based on your needs</p> sshd_config<pre><code>#Port 22\nPort 1234\n</code></pre> </li> <li> <p>Restart the SSH service     <pre><code>sudo service ssh restart\n</code></pre></p> </li> </ol>"},{"location":"docs/ssh/server-configuration/#limit-authenticate-users-to-login","title":"Limit authenticate users to login","text":"<ol> <li> <p>Go to your remote server, find, and open <code>/etc/ssh/sshd_config</code>.</p> <pre><code>sudo nano /etc/ssh/sshd_config\n</code></pre> </li> <li> <p>Search for <code>AllowUsers</code> or <code>AllowGroups</code>, if not found, then create it anywhere. Either one should be fine, or you want to implement both too.</p> sshd_config<pre><code>AllowUsers user1 user2 user3\nAllowGroups groupname\n</code></pre> </li> <li> <p>Restart the SSH service</p> <pre><code>sudo service ssh restart\n</code></pre> </li> </ol>"},{"location":"docs/ssh/server-configuration/#disable-root-login","title":"Disable root login","text":"<p>It is a good practice to disable root login</p> <ol> <li> <p>Go to your remote server, find, and open <code>/etc/ssh/sshd_config</code>.</p> <pre><code>sudo nano /etc/ssh/sshd_config\n</code></pre> </li> <li> <p>Search for <code>PermitRootLogin</code> text and set it to \"no\".</p> sshd_config<pre><code>PermitRootLogin no\n</code></pre> </li> <li> <p>Restart the SSH service</p> <pre><code>sudo service ssh restart\n</code></pre> </li> </ol>"},{"location":"docs/ssh/ssh-installation/","title":"SSH Installation","text":"More Information <p>For Windows Users: Enable WSL and SSH into Windows with Bash. Get started with OpenSSH for Windows</p>"},{"location":"docs/ssh/ssh-installation/#install-ssh-on-linux","title":"Install SSH on Linux","text":"<pre><code>sudo apt-get update\nsudo apt-get install -y openssh-client openssh-server\nsudo systemctl enable ssh\nsudo systemctl start ssh\n\n# you can trigger either one will do\nsudo systemctl status ssh\nsudo systemctl status sshd\n</code></pre> <p>You can find all the files under <code>/home/&lt;username&gt;/.ssh</code></p>"},{"location":"docs/ssh/ssh-overview/","title":"SSH Overview","text":""},{"location":"docs/ssh/ssh-overview/#what-is-ssh","title":"What is SSH?","text":"<p>SSH stands for Secure Shell (SSH) Protocol that is mainly used to connect to a Linux server remotely. Basically, it gives you the opportunity to access a server/computer over an unsecured network.</p>"},{"location":"docs/ssh/ssh-overview/#how-ssh-works","title":"How SSH Works?","text":"<p>Client-server architecture is used to implement SSH connections. The remote machine (Server) must be running SSH daemon (The heart of SSH). In SSH, a specific network port (22) is used for connection requests, authentication, and login into shell sessions when the user provides the correct credentials.</p>"},{"location":"docs/ssh/ssh-overview/#how-ssh-authenticate-users","title":"How SSH Authenticate Users?","text":"<p>We can use passwords or SSH keys to authenticate the right users to login.</p>"},{"location":"docs/ssh/ssh-overview/#password","title":"Password","text":"<p>It is not recommended to use passwords to log in, as when the malicious users or bots will keep repeatedly trying to authenticate their accounts, it might potentially lead to security compromises although password logins are encrypted. Therefore, it is less secure compared to SSH Keys.</p>"},{"location":"docs/ssh/ssh-overview/#ssh-keys","title":"SSH Keys","text":"<p>The SSH keys consist of both public and private cryptographic keys. For the public key, the user can share with anyone freely without any concerns, while the private key must be stored in a secure way and cannot be exposed to anyone.</p> <p></p> <p>Steps to authenticate;</p> <ol> <li>The clients must have an SSH key pair (public and private) on their local computers.</li> <li>The local client's public key must be copied to the user's home directory at <code>~/.ssh/authorized_keys</code> on the remote server.</li> <li>When the client connects to the host/server, it will inform the server which public key to use to authenticate.</li> <li>The server will validate the public key from <code>~/.ssh/authorized_keys</code> file, if it is valid, then it will generate a random string and encrypt it using the public key.</li> <li>The server will send the encrypted message to the client to test whether the client has the associated private key.</li> <li>After receiving an encrypted message from the server, the client will use the client's private key to decrypt and send the decrypted information back to the server.</li> <li>Lastly,the client is able to log into shell sessions when the server determines that the client has the associated private key by validating the decrypted information is correct.</li> </ol>"}]}